/**
  * Copyright (c) Carnegie Mellon University.
  * See LICENSE.txt for the conditions of this license.
  */

package edu.cmu.cs.ls.keymaerax.codegen

import java.io.File

import edu.cmu.cs.ls.keymaerax.btactics._
import edu.cmu.cs.ls.keymaerax.core.{NamedSymbol, Variable}
import edu.cmu.cs.ls.keymaerax.parser.KeYmaeraXParser
import edu.cmu.cs.ls.keymaerax.launcher.KeYmaeraX
import edu.cmu.cs.ls.keymaerax.parser.StringConverter._
import testHelper.KeYmaeraXTestTags.IgnoreInBuildTest

/**
 * Tests the C++ ModelPlex code generator.
 * @author Ran Ji
 * @author Stefan Mitsch
 */
class CCodeGeneratorTests extends TacticTestBase {

  override def beforeEach(): Unit = {
    super.beforeEach()
    CPrettyPrinter.printer = new CExpressionPlainPrettyPrinter()
  }

  override def afterEach(): Unit = {
    CPrettyPrinter.printer = new CExpressionPlainPrettyPrinter()
    super.afterEach()
  }

  // terms

  /** Wraps the monitor expression in the monitor boilerplate code. */
  private def expectedMonitor(compiledMonitorExpr: String,
                              paramDecl: String = "", stateDecl: String = "", inputDecl: String = "",
                              kind: String = "boolean"): String = {
    val (safetyDistBody, monitorSatisfiedBody) = kind match {
      case "boolean" => (s"return $compiledMonitorExpr ? 1.0L : -1.0L", "boundaryDist(pre,curr,params) >= 0.0L")
      case "program" => (compiledMonitorExpr, "boundaryDist(pre,curr,params) >= 0.0L")
      case "metric" => (
        "return " + compiledMonitorExpr.substring(0, compiledMonitorExpr.indexOf(" >")),
        "boundaryDist(pre,curr,params)" + compiledMonitorExpr.substring(compiledMonitorExpr.indexOf(" >")))
    }

    def structBody(body: String) = if (body.isEmpty) "" else "{\n  " + body + "\n} "

    s"""/**************************
       | *
       | * Generated by KeYmaera X
       | **************************/
       |
       |#include <math.h>
       |#include <stdbool.h>
       |
       |typedef struct parameters ${structBody(paramDecl)}parameters;
       |
       |typedef struct state ${structBody(stateDecl)}state;
       |
       |typedef struct input ${structBody(inputDecl)}input;
       |
       |
       |/* Computes distance to safety boundary on prior and current state (>=0 is safe, <0 is unsafe) */
       |long double boundaryDist(state pre, state curr, const parameters* const params) {
       |  $safetyDistBody;
       |}
       |
       |/* Evaluates monitor condition in prior and current state */
       |bool monitorSatisfied(state pre, state curr, const parameters* const params) {
       |  return $monitorSatisfiedBody;
       |}
       |
       |/* Run controller `ctrl` monitored, return `fallback` if `ctrl` violates monitor */
       |state monitoredCtrl(state curr, const parameters* const params, const input* const in,
       |                    state (*ctrl)(state,const parameters* const,const input* const), state (*fallback)(state,const parameters* const,const input* const)) {
       |  state pre = curr;
       |  state post = (*ctrl)(pre,params,in);
       |  if (!monitorSatisfied(pre,post,params)) return (*fallback)(pre,params,in);
       |  else return post;
       |}
       |
       |""".stripMargin
  }

  "numbers" should "compile floating point" in {
    val monitor = (new CGenerator(new CMonitorGenerator()))("2+1.5>3.25".asFormula)
    monitor._1 shouldBe expectedMonitor("(2.0L)+(1.5L) > 3.25L")
    monitor._2 shouldBe ""
  }

  it should "compile large number" in {
    val monitor = (new CGenerator(new CMonitorGenerator()))("9223372036854775807>1".asFormula)
    monitor._1 shouldBe expectedMonitor("9223372036854775807.0L > 1.0L")
    monitor._2 shouldBe ""
  }

  it should "throw exception for too large number" in {
    a [CodeGenerationException] should be thrownBy (new CGenerator(new CMonitorGenerator()))("92233720368547758079>1".asFormula)
  }

  "variables" should "compile with index" in {
    val paramDecls =
      """long double y_1;
        |  long double z;""".stripMargin
    val stateDecls = "long double x;"
    val monitor = (new CGenerator(new CMonitorGenerator()))("x*z-y_1>1".asFormula, Set(Variable("x")))
    monitor._1 shouldBe expectedMonitor("((pre.x)*(params->z))-(params->y_1) > 1.0L", paramDecls, stateDecls)
    monitor._2 shouldBe ""
  }

  "nullary functions" should "compile to parameters" in {
    val monitor = (new CGenerator(new CMonitorGenerator()))("x()>1".asFormula)
    monitor._1 shouldBe expectedMonitor("params->x > 1.0L", "long double x;")
    monitor._2 shouldBe ""
  }

  "terms" should "compile plain" in {
    val monitor = (new CGenerator(new CMonitorGenerator()))("x+3*y > 1".asFormula, Set(Variable("x")))
    monitor._1 shouldBe expectedMonitor("(pre.x)+((3.0L)*(params->y)) > 1.0L", "long double y;", "long double x;")
    monitor._2 shouldBe ""
  }

  it should "compile with log" in {
    CPrettyPrinter.printer = new CExpressionLogPrettyPrinter()
    val monitor = (new CGenerator(new CMonitorGenerator()))("x+3*y > 1".asFormula, Set(Variable("x")))
    monitor._1 shouldBe
      expectedMonitor(
        """eval(gt(plus(variable(pre.x, "pre.x"), times(number(3), variable(params->y, "params->y"))), number(1)))""",
        "long double y;", "long double x;")
    monitor._2 shouldBe ""
  }

  "power" should "compile int exp" in {
    val monitor = (new CGenerator(new CMonitorGenerator()))("x^3>1".asFormula)
    monitor._1 shouldBe expectedMonitor("(params->x)*((params->x)*(params->x)) > 1.0L", "long double x;")
    monitor._2 shouldBe ""
  }

  it should "compile exp=1" in {
    val monitor = (new CGenerator(new CMonitorGenerator()))("x^1>1".asFormula)
    monitor._1 shouldBe expectedMonitor("params->x > 1.0L", "long double x;")
    monitor._2 shouldBe ""
  }

  it should "compile neg int exp" in {
    val paramDecls =
      """long double x;
        |  long double y;""".stripMargin
    val monitor = (new CGenerator(new CMonitorGenerator()))("(x+y)^-3>1".asFormula)
    monitor._1 shouldBe expectedMonitor(
      "(1.0L)/(((params->x)+(params->y))*(((params->x)+(params->y))*((params->x)+(params->y)))) > 1.0L", paramDecls)
    monitor._2 shouldBe ""
  }

  it should "compile any exp" in {
    val paramDecls =
      """long double x;
        |  long double y;""".stripMargin
    val monitor = (new CGenerator(new CMonitorGenerator()))("x^y>1".asFormula)
    monitor._1 shouldBe expectedMonitor("pow(params->x,params->y) > 1.0L", paramDecls)
    monitor._2 shouldBe ""
  }

  "abs" should "compile" in {
    val paramDecls =
      """long double x;
        |  long double y;""".stripMargin
    val monitor = (new CGenerator(new CMonitorGenerator()))("abs(x-y)>0".asFormula)
    monitor._1 shouldBe expectedMonitor("fabsl((params->x)-(params->y)) > 0.0L", paramDecls)
    monitor._2 shouldBe ""
  }

  "min" should "compile" in {
    val paramDecls =
      """long double x;
        |  long double y;""".stripMargin
    val monitor = (new CGenerator(new CMonitorGenerator()))("min(x,y)<=x".asFormula)
    monitor._1 shouldBe expectedMonitor("-(fminl(params->x, params->y)) >= -(params->x)", paramDecls, "", "", "metric")
    monitor._2 shouldBe ""
  }

  "max" should "compile" in {
    val paramDecls =
      """long double x;
        |  long double y;""".stripMargin
    val monitor = (new CGenerator(new CMonitorGenerator()))("max(x,y)>=x".asFormula)
    monitor._1 shouldBe expectedMonitor("fmaxl(params->x, params->y) >= params->x", paramDecls)
    monitor._2 shouldBe ""
  }

  "A program with tests" should "compile" in withMathematica { _ =>
    val paramDecls =
      """long double x;
        |  long double y;""".stripMargin
    val monitor = (new CGenerator(new CMonitorGenerator()))("<?x>=y;>true".asFormula)
    monitor._1 shouldBe expectedMonitor(
      """if (params->x >= params->y) {
        |return (0.0L)+(-((params->y)-(params->x)));
        |} else {
        |printf("Failed %s\n", "x>=y"); return ((-1.0L))+(-((params->y)-(params->x)));
        |}""".stripMargin, paramDecls,
      "", "", "program")
    monitor._2 shouldBe ""
  }

  "C generator" should "compile function with 2 parameters" ignore {
    (new CGenerator(new CMonitorGenerator()))("f(x,y)>g(y,z)".asFormula) should be("/**************************\n * Generated by KeYmaera X\n **************************/\n\n" +
      "#include <math.h>\n#include <stdbool.h>\n\n" +
      "/* function declaration */\nlong double f(long double, long double);\nlong double g(long double, long double);\nlong double x();\nlong double y();\nlong double z();\n\n" +
      "/* monitor */\nbool monitor () {\n  return (f(x(), y()))>(g(y(), z()));\n}\n\n")
  }

  it should "compile function with more parameters" ignore {
    (new CGenerator(new CMonitorGenerator()))("f(x,y,z)>0".asFormula) should be("/**************************\n * Generated by KeYmaera X\n **************************/\n\n" +
      "#include <math.h>\n#include <stdbool.h>\n\n" +
      "/* function declaration */\nlong double f(long double, long double, long double);\nlong double x();\nlong double y();\nlong double z();\n\n" +
      "/* monitor */\nbool monitor () {\n  return (f(x(), y(), z()))>((0.0L));\n}\n\n")
  }


  // hacms case studies

  "robix" should "generate C code for passivesafety" in {
    val inputFile = getClass.getResourceAsStream("/examples/casestudies/robix/passivesafety.kym")
    val monitorExp = KeYmaeraXParser(io.Source.fromInputStream(inputFile).mkString)
    val paramDecls =
      """long double A;
        |  long double B;
        |  long double V;
        |  long double ep;
        |  long double v;
        |  long double x;
        |  long double y;""".stripMargin
    val stateDecls =
      """long double a;
        |  long double dxo;
        |  long double dyo;
        |  long double r;
        |  long double t;
        |  long double w;
        |  long double xo;
        |  long double yo;""".stripMargin
    val genCode = (new CGenerator(new CMonitorGenerator()))(monitorExp, Set(Variable("a"),Variable("w"),Variable("r"),Variable("xo"),Variable("yo"),
      Variable("dxo"),Variable("dyo"),Variable("t")))
    genCode shouldBe (expectedMonitor(
      "(((curr.dxo)*(curr.dxo))+((curr.dyo)*(curr.dyo)) <= (params->V)*(params->V)) && (((curr.a == -(params->B)) && ((curr.w == pre.w) && ((curr.r == pre.r) && ((curr.xo == pre.xo) && ((curr.yo == pre.yo) && ((curr.dxo == curr.dxo) && ((curr.dyo == curr.dyo) && (curr.t == 0.0L)))))))) || (((params->v == 0.0L) && ((curr.a == 0.0L) && ((curr.w == 0.0L) && ((curr.r == pre.r) && ((curr.xo == pre.xo) && ((curr.yo == pre.yo) && ((curr.dxo == curr.dxo) && ((curr.dyo == curr.dyo) && (curr.t == 0.0L))))))))) || ((-(params->B) <= curr.a) && ((curr.a <= params->A) && ((curr.r != 0.0L) && (((curr.w)*(curr.r) == params->v) && (((((!((params->x)-(curr.xo) >= 0.0L)) || ((params->x)-(curr.xo) > ((((params->v)*(params->v))/((2.0L)*(params->B)))+(((params->V)*(params->v))/(params->B)))+((((params->A)/(params->B))+(1.0L))*((((params->A)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((params->v)+(params->V))))))) && ((!((params->x)-(curr.xo) <= 0.0L)) || ((curr.xo)-(params->x) > ((((params->v)*(params->v))/((2.0L)*(params->B)))+(((params->V)*(params->v))/(params->B)))+((((params->A)/(params->B))+(1.0L))*((((params->A)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((params->v)+(params->V)))))))) || (((!((params->y)-(curr.yo) >= 0.0L)) || ((params->y)-(curr.yo) > ((((params->v)*(params->v))/((2.0L)*(params->B)))+(((params->V)*(params->v))/(params->B)))+((((params->A)/(params->B))+(1.0L))*((((params->A)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((params->v)+(params->V))))))) && ((!((params->y)-(curr.yo) <= 0.0L)) || ((curr.yo)-(params->y) > ((((params->v)*(params->v))/((2.0L)*(params->B)))+(((params->V)*(params->v))/(params->B)))+((((params->A)/(params->B))+(1.0L))*((((params->A)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((params->v)+(params->V))))))))) && ((curr.a == curr.a) && ((curr.w == curr.w) && ((curr.r == curr.r) && ((curr.xo == curr.xo) && ((curr.yo == curr.yo) && ((curr.dxo == curr.dxo) && ((curr.dyo == curr.dyo) && (curr.t == 0.0L)))))))))))))))",
      paramDecls, stateDecls), "")
    }

  it should "generate C code for passivesafety_renamed" in {
    val inputFile = getClass.getResourceAsStream("/examples/casestudies/robix/passivesafety_renamed.kym")
    val monitorExp = KeYmaeraXParser(io.Source.fromInputStream(inputFile).mkString)
    val paramDecls =
      """long double A;
        |  long double B;
        |  long double Vo;
        |  long double ep;
        |  long double v;
        |  long double x;
        |  long double y;""".stripMargin
    val stateDecls =
      """long double a;
        |  long double dxo;
        |  long double dyo;
        |  long double om;
        |  long double r;
        |  long double t;
        |  long double xo;
        |  long double yo;""".stripMargin
    val genCode = (new CGenerator(new CMonitorGenerator()))(monitorExp, Set(Variable("a"),Variable("om"),Variable("r"),Variable("xo"),Variable("yo"),
      Variable("dxo"),Variable("dyo"),Variable("t")))
    genCode._1 shouldBe
      expectedMonitor(
        "(((curr.dxo)*(curr.dxo))+((curr.dyo)*(curr.dyo)) <= (params->Vo)*(params->Vo)) && (((curr.a == -(params->B)) && ((curr.om == pre.om) && ((curr.r == pre.r) && ((curr.xo == pre.xo) && ((curr.yo == pre.yo) && ((curr.dxo == curr.dxo) && ((curr.dyo == curr.dyo) && (curr.t == 0.0L)))))))) || (((params->v == 0.0L) && ((curr.a == 0.0L) && ((curr.om == 0.0L) && ((curr.r == pre.r) && ((curr.xo == pre.xo) && ((curr.yo == pre.yo) && ((curr.dxo == curr.dxo) && ((curr.dyo == curr.dyo) && (curr.t == 0.0L))))))))) || ((-(params->B) <= curr.a) && ((curr.a <= params->A) && ((curr.r != 0.0L) && (((curr.om)*(curr.r) == params->v) && (((((!((params->x)-(curr.xo) >= 0.0L)) || ((params->x)-(curr.xo) > ((((params->v)*(params->v))/((2.0L)*(params->B)))+(((params->Vo)*(params->v))/(params->B)))+((((params->A)/(params->B))+(1.0L))*((((params->A)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((params->v)+(params->Vo))))))) && ((!((params->x)-(curr.xo) <= 0.0L)) || ((curr.xo)-(params->x) > ((((params->v)*(params->v))/((2.0L)*(params->B)))+(((params->Vo)*(params->v))/(params->B)))+((((params->A)/(params->B))+(1.0L))*((((params->A)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((params->v)+(params->Vo)))))))) || (((!((params->y)-(curr.yo) >= 0.0L)) || ((params->y)-(curr.yo) > ((((params->v)*(params->v))/((2.0L)*(params->B)))+(((params->Vo)*(params->v))/(params->B)))+((((params->A)/(params->B))+(1.0L))*((((params->A)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((params->v)+(params->Vo))))))) && ((!((params->y)-(curr.yo) <= 0.0L)) || ((curr.yo)-(params->y) > ((((params->v)*(params->v))/((2.0L)*(params->B)))+(((params->Vo)*(params->v))/(params->B)))+((((params->A)/(params->B))+(1.0L))*((((params->A)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((params->v)+(params->Vo))))))))) && ((curr.a == curr.a) && ((curr.om == curr.om) && ((curr.r == curr.r) && ((curr.xo == curr.xo) && ((curr.yo == curr.yo) && ((curr.dxo == curr.dxo) && ((curr.dyo == curr.dyo) && (curr.t == 0.0L)))))))))))))))",
        paramDecls, stateDecls)
    genCode._2 shouldBe ""
  }

  it should "generate C code for passivesafetyabs" in {
    val inputFile = getClass.getResourceAsStream("/examples/casestudies/robix/passivesafetyabs.kym")
    val monitorExp = KeYmaeraXParser(io.Source.fromInputStream(inputFile).mkString)
    val vars =
      Set(Variable("a"),Variable("dx"),Variable("dy"),Variable("r"),Variable("v"),Variable("w"),Variable("x"),Variable("y"),
        Variable("xo"),Variable("yo"),Variable("dxo"),Variable("dyo"),Variable("t"))
    val paramDecls =
      """long double A;
        |  long double B;
        |  long double V;
        |  long double ep;""".stripMargin
    val stateDecls =
      """long double a;
        |  long double dx;
        |  long double dxo;
        |  long double dy;
        |  long double dyo;
        |  long double r;
        |  long double t;
        |  long double v;
        |  long double w;
        |  long double x;
        |  long double xo;
        |  long double y;
        |  long double yo;""".stripMargin
    val genCode = (new CGenerator(new CMonitorGenerator()))(monitorExp, vars)
    genCode._1 shouldBe
      expectedMonitor(
        "(((curr.dxo)*(curr.dxo))+((curr.dyo)*(curr.dyo)) <= (params->V)*(params->V)) && ((((0.0L <= params->ep) && (pre.v >= 0.0L)) && (((((((((((((curr.xo == pre.xo) && (curr.yo == pre.yo)) && (curr.dxo == curr.dxo)) && (curr.dyo == curr.dyo)) && (curr.x == pre.x)) && (curr.y == pre.y)) && (curr.dx == pre.dx)) && (curr.dy == pre.dy)) && (curr.v == pre.v)) && (curr.w == pre.w)) && (curr.a == -(params->B))) && (curr.r == pre.r)) && (curr.t == 0.0L))) || (((pre.v == 0.0L) && (((0.0L <= params->ep) && (pre.v >= 0.0L)) && (((((((((((((curr.xo == pre.xo) && (curr.yo == pre.yo)) && (curr.dxo == curr.dxo)) && (curr.dyo == curr.dyo)) && (curr.x == pre.x)) && (curr.y == pre.y)) && (curr.dx == pre.dx)) && (curr.dy == pre.dy)) && (curr.v == pre.v)) && (curr.w == 0.0L)) && (curr.a == 0.0L)) && (curr.r == pre.r)) && (curr.t == 0.0L)))) || (((-(params->B) <= curr.a) && (curr.a <= params->A)) && ((curr.r != 0.0L) && (((curr.w)*(curr.r) == pre.v) && (((fabsl((pre.x)-(curr.xo)) > ((((pre.v)*(pre.v))/((2.0L)*(params->B)))+(((params->V)*(pre.v))/(params->B)))+((((params->A)/(params->B))+(1.0L))*((((params->A)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((pre.v)+(params->V)))))) || (fabsl((pre.y)-(curr.yo)) > ((((pre.v)*(pre.v))/((2.0L)*(params->B)))+(((params->V)*(pre.v))/(params->B)))+((((params->A)/(params->B))+(1.0L))*((((params->A)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((pre.v)+(params->V))))))) && (((0.0L <= params->ep) && (pre.v >= 0.0L)) && (((((((((((((curr.xo == curr.xo) && (curr.yo == curr.yo)) && (curr.dxo == curr.dxo)) && (curr.dyo == curr.dyo)) && (curr.x == pre.x)) && (curr.y == pre.y)) && (curr.dx == pre.dx)) && (curr.dy == pre.dy)) && (curr.v == pre.v)) && (curr.w == curr.w)) && (curr.a == curr.a)) && (curr.r == curr.r)) && (curr.t == 0.0L)))))))))",
        paramDecls, stateDecls)
    genCode._2 shouldBe ""
  }

  it should "generate metric C code for passivesafetyabs" in withMathematica { _ =>
    val inputFile = getClass.getResourceAsStream("/examples/casestudies/robix/passivesafetyabs.kym")
    val monitorExp = ModelPlex.toMetric(io.Source.fromInputStream(inputFile).mkString.asFormula)
    val vars =
      Set(Variable("a"),Variable("dx"),Variable("dy"),Variable("r"),Variable("v"),Variable("w"),Variable("x"),Variable("y"),
        Variable("xo"),Variable("yo"),Variable("dxo"),Variable("dyo"),Variable("t"))
    val paramDecls =
      """long double A;
        |  long double B;
        |  long double V;
        |  long double ep;""".stripMargin
    val stateDecls =
      """long double a;
        |  long double dx;
        |  long double dxo;
        |  long double dy;
        |  long double dyo;
        |  long double r;
        |  long double t;
        |  long double v;
        |  long double w;
        |  long double x;
        |  long double xo;
        |  long double y;
        |  long double yo;""".stripMargin
    val genCode = (new CGenerator(new CMonitorGenerator))(monitorExp, vars)
    genCode._1 shouldBe
      expectedMonitor(
        "-(fmaxl((((curr.dxo)*(curr.dxo))+((curr.dyo)*(curr.dyo)))-((params->V)*(params->V)), fminl(fmaxl(fmaxl((0.0L)-(params->ep), (0.0L)-(pre.v)), fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl((curr.xo)-(pre.xo), (pre.xo)-(curr.xo)), fmaxl((curr.yo)-(pre.yo), (pre.yo)-(curr.yo))), fmaxl((curr.dxo)-(curr.dxo), (curr.dxo)-(curr.dxo))), fmaxl((curr.dyo)-(curr.dyo), (curr.dyo)-(curr.dyo))), fmaxl((curr.x)-(pre.x), (pre.x)-(curr.x))), fmaxl((curr.y)-(pre.y), (pre.y)-(curr.y))), fmaxl((curr.dx)-(pre.dx), (pre.dx)-(curr.dx))), fmaxl((curr.dy)-(pre.dy), (pre.dy)-(curr.dy))), fmaxl((curr.v)-(pre.v), (pre.v)-(curr.v))), fmaxl((curr.w)-(pre.w), (pre.w)-(curr.w))), fmaxl((curr.a)-(-(params->B)), (-(params->B))-(curr.a))), fmaxl((curr.r)-(pre.r), (pre.r)-(curr.r))), fmaxl(curr.t, (0.0L)-(curr.t)))), fminl(fmaxl(fmaxl(pre.v, (0.0L)-(pre.v)), fmaxl(fmaxl((0.0L)-(params->ep), (0.0L)-(pre.v)), fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl((curr.xo)-(pre.xo), (pre.xo)-(curr.xo)), fmaxl((curr.yo)-(pre.yo), (pre.yo)-(curr.yo))), fmaxl((curr.dxo)-(curr.dxo), (curr.dxo)-(curr.dxo))), fmaxl((curr.dyo)-(curr.dyo), (curr.dyo)-(curr.dyo))), fmaxl((curr.x)-(pre.x), (pre.x)-(curr.x))), fmaxl((curr.y)-(pre.y), (pre.y)-(curr.y))), fmaxl((curr.dx)-(pre.dx), (pre.dx)-(curr.dx))), fmaxl((curr.dy)-(pre.dy), (pre.dy)-(curr.dy))), fmaxl((curr.v)-(pre.v), (pre.v)-(curr.v))), fmaxl(curr.w, (0.0L)-(curr.w))), fmaxl(curr.a, (0.0L)-(curr.a))), fmaxl((curr.r)-(pre.r), (pre.r)-(curr.r))), fmaxl(curr.t, (0.0L)-(curr.t))))), fmaxl(fmaxl((-(params->B))-(curr.a), (curr.a)-(params->A)), fmaxl(fminl((0.0L)-(curr.r), curr.r), fmaxl(fmaxl(((curr.w)*(curr.r))-(pre.v), (pre.v)-((curr.w)*(curr.r))), fmaxl(fminl((((((pre.v)*(pre.v))/((2.0L)*(params->B)))+(((params->V)*(pre.v))/(params->B)))+((((params->A)/(params->B))+(1.0L))*((((params->A)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((pre.v)+(params->V))))))-(fabsl((pre.x)+(-(curr.xo)))), (((((pre.v)*(pre.v))/((2.0L)*(params->B)))+(((params->V)*(pre.v))/(params->B)))+((((params->A)/(params->B))+(1.0L))*((((params->A)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((pre.v)+(params->V))))))-(fabsl((pre.y)+(-(curr.yo))))), fmaxl(fmaxl((0.0L)-(params->ep), (0.0L)-(pre.v)), fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl((curr.xo)-(curr.xo), (curr.xo)-(curr.xo)), fmaxl((curr.yo)-(curr.yo), (curr.yo)-(curr.yo))), fmaxl((curr.dxo)-(curr.dxo), (curr.dxo)-(curr.dxo))), fmaxl((curr.dyo)-(curr.dyo), (curr.dyo)-(curr.dyo))), fmaxl((curr.x)-(pre.x), (pre.x)-(curr.x))), fmaxl((curr.y)-(pre.y), (pre.y)-(curr.y))), fmaxl((curr.dx)-(pre.dx), (pre.dx)-(curr.dx))), fmaxl((curr.dy)-(pre.dy), (pre.dy)-(curr.dy))), fmaxl((curr.v)-(pre.v), (pre.v)-(curr.v))), fmaxl((curr.w)-(curr.w), (curr.w)-(curr.w))), fmaxl((curr.a)-(curr.a), (curr.a)-(curr.a))), fmaxl((curr.r)-(curr.r), (curr.r)-(curr.r))), fmaxl(curr.t, (0.0L)-(curr.t)))))))))))) > -(0.0L)",
        paramDecls, stateDecls, "",
        "metric")
    genCode._2 shouldBe ""
  }

  it should "generate C code for passivesafetyabs with KeYmaeraX command line interface" taggedAs IgnoreInBuildTest in {
    // command line main has to initialize the prover itself, so dispose all test setup first
//    afterEach()

    val inputFileName = "./keymaerax-webui/src/test/resources/examples/casestudies/robix/passivesafetyabs.kym"
    val outputFileName = File.createTempFile("passivesafetyabs", ".c").getAbsolutePath

    KeYmaeraX.main(Array("-codegen", inputFileName, "-vars", "a,w,r,xo,yo,dxo,dyo", "-nointerval", "-out", outputFileName))

    val expectedCCode = scala.io.Source.fromFile("./keymaerax-webui/src/test/resources/examples/casestudies/robix/passivesafetyabs.c").mkString
    val actualFileContent = scala.io.Source.fromFile(outputFileName).mkString
    println(actualFileContent)

    actualFileContent should include (expectedCCode)
  }

  it should "generate C code for passiveorientationsafety" in {
    val inputFile = getClass.getResourceAsStream("/examples/casestudies/robix/passiveorientationsafety.kym")
    val monitorExp = KeYmaeraXParser(io.Source.fromInputStream(inputFile).mkString)
    val paramDecls =
      """long double A;
        |  long double V;
        |  long double alpha;
        |  long double b;
        |  long double ep;
        |  long double v;
        |  long double x;
        |  long double y;""".stripMargin
    val stateDecls =
      """long double a;
        |  long double dx;
        |  long double dy;
        |  long double isVisible;
        |  long double odx;
        |  long double ody;
        |  long double ox;
        |  long double oy;
        |  long double r;
        |  long double t;
        |  long double talpha;
        |  long double w;""".stripMargin
    val genCode = (new CGenerator(new CMonitorGenerator()))(monitorExp,
      Set(Variable("a"), Variable("w"), Variable("dx"), Variable("dy"), Variable("r"), Variable("t"), Variable("ox"),
           Variable("oy"), Variable("odx"), Variable("ody"), Variable("isVisible"),
           Variable("talpha")))
    genCode._1 shouldBe
      expectedMonitor(
        "(((curr.odx)*(curr.odx))+((curr.ody)*(curr.ody)) <= (params->V)*(params->V)) && ((((curr.w)*(pre.r) == params->v) && ((curr.a == -(params->b)) && ((curr.w == curr.w) && ((curr.dx == pre.dx) && ((curr.dy == pre.dy) && ((curr.r == pre.r) && ((curr.t == 0.0L) && ((curr.ox == pre.ox) && ((curr.oy == pre.oy) && ((curr.odx == curr.odx) && ((curr.ody == curr.ody) && ((curr.isVisible == pre.isVisible) && (curr.talpha == pre.talpha))))))))))))) || (((params->v == 0.0L) && (((curr.w)*(pre.r) == params->v) && ((curr.a == 0.0L) && ((curr.w == curr.w) && ((curr.dx == -(pre.dx)) && ((curr.dy == -(pre.dy)) && ((curr.r == pre.r) && ((curr.t == 0.0L) && ((curr.ox == pre.ox) && ((curr.oy == pre.oy) && ((curr.odx == curr.odx) && ((curr.ody == curr.ody) && ((curr.isVisible == pre.isVisible) && (curr.talpha == pre.talpha)))))))))))))) || ((-(params->b) <= curr.a) && ((curr.a <= params->A) && ((curr.r != 0.0L) && ((((params->v)+((curr.a)*(params->ep)) < 0.0L) && (((curr.isVisible < 0.0L) || ((((!((params->x)-(curr.ox) >= 0.0L)) || ((params->x)-(curr.ox) > (((params->v)*(params->v))/(((-2.0L))*(curr.a)))+((params->V)*((params->v)/(-(curr.a)))))) && ((!((params->x)-(curr.ox) <= 0.0L)) || ((curr.ox)-(params->x) > (((params->v)*(params->v))/(((-2.0L))*(curr.a)))+((params->V)*((params->v)/(-(curr.a))))))) || (((!((params->y)-(curr.oy) >= 0.0L)) || ((params->y)-(curr.oy) > (((params->v)*(params->v))/(((-2.0L))*(curr.a)))+((params->V)*((params->v)/(-(curr.a)))))) && ((!((params->y)-(curr.oy) <= 0.0L)) || ((curr.oy)-(params->y) > (((params->v)*(params->v))/(((-2.0L))*(curr.a)))+((params->V)*((params->v)/(-(curr.a))))))))) && (((!(curr.r >= 0.0L)) || (((params->v)*(params->v))/(((-2.0L))*(curr.a)) < (params->alpha)*(curr.r))) && (((!(curr.r < 0.0L)) || (((params->v)*(params->v))/(((-2.0L))*(curr.a)) < -((params->alpha)*(curr.r)))) && (((curr.w)*(curr.r) == params->v) && ((curr.a == curr.a) && ((curr.w == curr.w) && ((curr.dx == pre.dx) && ((curr.dy == pre.dy) && ((curr.r == curr.r) && ((curr.t == 0.0L) && ((curr.ox == curr.ox) && ((curr.oy == curr.oy) && ((curr.odx == curr.odx) && ((curr.ody == curr.ody) && ((curr.isVisible == curr.isVisible) && (curr.talpha == 0.0L))))))))))))))))) || (((params->v)+((curr.a)*(params->ep)) >= 0.0L) && (((curr.isVisible < 0.0L) || ((((!((params->x)-(curr.ox) >= 0.0L)) || ((params->x)-(curr.ox) > ((((params->v)*(params->v))/((2.0L)*(params->b)))+((params->V)*((params->v)/(params->b))))+((((curr.a)/(params->b))+(1.0L))*((((curr.a)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((params->v)+(params->V))))))) && ((!((params->x)-(curr.ox) <= 0.0L)) || ((curr.ox)-(params->x) > ((((params->v)*(params->v))/((2.0L)*(params->b)))+((params->V)*((params->v)/(params->b))))+((((curr.a)/(params->b))+(1.0L))*((((curr.a)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((params->v)+(params->V)))))))) || (((!((params->y)-(curr.oy) >= 0.0L)) || ((params->y)-(curr.oy) > ((((params->v)*(params->v))/((2.0L)*(params->b)))+((params->V)*((params->v)/(params->b))))+((((curr.a)/(params->b))+(1.0L))*((((curr.a)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((params->v)+(params->V))))))) && ((!((params->y)-(curr.oy) <= 0.0L)) || ((curr.oy)-(params->y) > ((((params->v)*(params->v))/((2.0L)*(params->b)))+((params->V)*((params->v)/(params->b))))+((((curr.a)/(params->b))+(1.0L))*((((curr.a)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*((params->v)+(params->V)))))))))) && (((!(curr.r >= 0.0L)) || ((((params->v)*(params->v))/((2.0L)*(params->b)))+((((curr.a)/(params->b))+(1.0L))*((((curr.a)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*(params->v)))) < (params->alpha)*(curr.r))) && (((!(curr.r < 0.0L)) || ((((params->v)*(params->v))/((2.0L)*(params->b)))+((((curr.a)/(params->b))+(1.0L))*((((curr.a)/(2.0L))*((params->ep)*(params->ep)))+((params->ep)*(params->v)))) < -((params->alpha)*(curr.r)))) && (((curr.w)*(curr.r) == params->v) && ((curr.a == curr.a) && ((curr.w == curr.w) && ((curr.dx == pre.dx) && ((curr.dy == pre.dy) && ((curr.r == curr.r) && ((curr.t == 0.0L) && ((curr.ox == curr.ox) && ((curr.oy == curr.oy) && ((curr.odx == curr.odx) && ((curr.ody == curr.ody) && ((curr.isVisible == curr.isVisible) && (curr.talpha == 0.0L)))))))))))))))))))))))",
        paramDecls, stateDecls)
    genCode._2 shouldBe ""
  }

  "quadcopter" should "generate C code for hybridquadrotor" in {
    val inputFile = getClass.getResourceAsStream("/examples/casestudies/quadcopter/hybridquadrotor.kym")
    val monitorExp = KeYmaeraXParser(io.Source.fromInputStream(inputFile).mkString)
    val paramDecls =
      """long double h;
        |  long double kd;
        |  long double kp;
        |  long double sqrkp;
        |  long double v;
        |  long double y;""".stripMargin
    val code = (new CGenerator(new CMonitorGenerator()))(monitorExp, Set(Variable("href")))
    println(code)
    code._1 shouldBe expectedMonitor(
      "(params->h >= curr.href) && ((curr.href > 0.0L) && ((((((params->kp < 0.0L) && ((params->v == 0.0L) && (curr.href >= params->h))) || (((params->kp < 0.0L) && ((params->v > 0.0L) && (((((2.0L)*(params->h))*(params->kp))+((params->v)*((params->kd)+(params->y))) == ((2.0L)*(curr.href))*(params->kp)) && ((params->h)*(params->y) > ((params->h)*(params->kd))+((2.0L)*(params->v)))))) || (((params->kp < 0.0L) && ((params->v < 0.0L) && (((((2.0L)*(curr.href))*(params->kp))+((params->v)*(params->y)) == (((2.0L)*(params->h))*(params->kp))+((params->kd)*(params->v))) && (((2.0L)*(params->v))+((params->h)*((params->kd)+(params->y))) > 0.0L)))) || (((params->kp > 0.0L) && ((params->v == 0.0L) && (curr.href == params->h))) || (((params->kp > 0.0L) && ((params->v > 0.0L) && ((((((2.0L)*(params->h))*(params->kp))+((params->v)*((params->kd)+(params->y))) == ((2.0L)*(curr.href))*(params->kp)) && (((params->h)*(params->y) > ((params->h)*(params->kd))+((2.0L)*(params->v))) && ((params->kd)+((2.0L)*(params->sqrkp)) <= 0.0L))) || ((((((2.0L)*(params->h))*(params->kp))+((params->v)*((params->kd)+(params->y))) == ((2.0L)*(curr.href))*(params->kp)) && (((params->kd)+((2.0L)*(params->sqrkp)) < 0.0L) && (((2.0L)*(params->v))+((params->h)*((params->kd)+(params->y))) < 0.0L))) || ((((((2.0L)*(curr.href))*(params->kp))+((params->v)*(params->y)) == (((2.0L)*(params->h))*(params->kp))+((params->kd)*(params->v))) && (((params->kd)+((2.0L)*(params->sqrkp)) < 0.0L) && (((2.0L)*(params->v))+((params->h)*((params->kd)+(params->y))) < 0.0L))) || (((((2.0L)*(params->h))*(params->kp))+((params->v)*((params->kd)+(params->y))) == ((2.0L)*(curr.href))*(params->kp)) && ((params->kd > (2.0L)*(params->sqrkp)) && ((((2.0L)*(params->v))+((params->h)*((params->kd)+(params->y))) > 0.0L) && ((params->h)*(params->y) >= ((params->h)*(params->kd))+((2.0L)*(params->v))))))))))) || ((params->kp > 0.0L) && ((params->v < 0.0L) && ((((((2.0L)*(params->h))*(params->kp))+((params->v)*((params->kd)+(params->y))) == ((2.0L)*(curr.href))*(params->kp)) && ((params->kd > (2.0L)*(params->sqrkp)) && ((params->h)*(params->y) < ((params->h)*(params->kd))+((2.0L)*(params->v))))) || ((((((2.0L)*(curr.href))*(params->kp))+((params->v)*(params->y)) == (((2.0L)*(params->h))*(params->kp))+((params->kd)*(params->v))) && ((params->kd >= (2.0L)*(params->sqrkp)) && ((params->h)*(params->y) < ((params->h)*(params->kd))+((2.0L)*(params->v))))) || ((((((2.0L)*(curr.href))*(params->kp))+((params->v)*(params->y)) == (((2.0L)*(params->h))*(params->kp))+((params->kd)*(params->v))) && ((params->kd > (2.0L)*(params->sqrkp)) && ((((2.0L)*(params->v))+((params->h)*((params->kd)+(params->y))) > 0.0L) && ((params->h)*(params->y) >= ((params->h)*(params->kd))+((2.0L)*(params->v)))))) || (((((2.0L)*(curr.href))*(params->kp))+((params->v)*(params->y)) == (((2.0L)*(params->h))*(params->kp))+((params->kd)*(params->v))) && (((params->h)*(params->y) > ((params->h)*(params->kd))+((2.0L)*(params->v))) && ((((2.0L)*(params->v))+((params->h)*((params->kd)+(params->y))) >= 0.0L) && ((params->kd)+((2.0L)*(params->sqrkp)) < 0.0L)))))))))))))) && ((((params->y)*(params->y) == ((params->kd)*(params->kd))-((4.0L)*(params->kp))) && (params->y >= 0.0L)) && ((((params->sqrkp)*(params->sqrkp) == params->kp) && (params->sqrkp >= 0.0L)) && ((((((((params->h)*(params->h))*((params->kp)*(params->kp)))-((((2.0L)*(params->h))*(curr.href))*((params->kp)*(params->kp))))+(((curr.href)*(curr.href))*((params->kp)*(params->kp))))+((((params->h)*(params->kd))*(params->kp))*(params->v)))-((((curr.href)*(params->kd))*(params->kp))*(params->v)))+((params->kp)*((params->v)*(params->v))) != 0.0L)))) || ((((params->kp < 0.0L) && ((params->v == 0.0L) && (((params->h)*(params->y) <= (params->h)*(params->kd)) || (((params->h)*((params->kd)+(params->y)) <= 0.0L) || (params->h > curr.href))))) || (((params->kp < 0.0L) && ((params->v < 0.0L) && (((params->h)*(params->y) <= ((params->h)*(params->kd))+((2.0L)*(params->v))) || ((((2.0L)*(params->v))+((params->h)*((params->kd)+(params->y))) <= 0.0L) || ((((2.0L)*(params->h))*(params->kp))+((params->kd)*(params->v)) != (((2.0L)*(curr.href))*(params->kp))+((params->v)*(params->y))))))) || (((params->kp < 0.0L) && ((params->v > 0.0L) && (((params->h)*(params->y) <= ((params->h)*(params->kd))+((2.0L)*(params->v))) || ((((2.0L)*(params->v))+((params->h)*((params->kd)+(params->y))) <= 0.0L) || ((((2.0L)*(params->h))*(params->kp))+((params->v)*((params->kd)+(params->y))) != ((2.0L)*(curr.href))*(params->kp)))))) || (((params->kp > 0.0L) && ((params->v == 0.0L) && (((params->h != curr.href) && (((params->kd >= (2.0L)*(params->sqrkp)) && ((params->h)*(params->y) >= (params->h)*(params->kd))) || (((params->h)*((params->kd)+(params->y)) >= 0.0L) && ((params->kd)+((2.0L)*(params->sqrkp)) < 0.0L)))) || (((params->kd == (2.0L)*(params->sqrkp)) && ((params->h)*(params->y) >= (params->h)*(params->kd))) || (((params->kd < (2.0L)*(params->sqrkp)) && ((params->kd)+((2.0L)*(params->sqrkp)) > 0.0L)) || ((params->h > curr.href) || (((params->kd > (2.0L)*(params->sqrkp)) && ((params->h)*((params->kd)+(params->y)) <= 0.0L)) || (((params->kd)+((2.0L)*(params->sqrkp)) <= 0.0L) && ((params->h)*(params->y) <= (params->h)*(params->kd)))))))))) || (((params->kp > 0.0L) && ((params->v < 0.0L) && ((((((2.0L)*(curr.href))*(params->kp))+((params->v)*(params->y)) != (((2.0L)*(params->h))*(params->kp))+((params->kd)*(params->v))) && (((params->h)*(params->y) >= ((params->h)*(params->kd))+((2.0L)*(params->v))) || (params->kd <= (2.0L)*(params->sqrkp)))) || ((params->kd < (2.0L)*(params->sqrkp)) || (((params->kd > (2.0L)*(params->sqrkp)) && ((((params->h)*(params->y) < ((params->h)*(params->kd))+((2.0L)*(params->v))) && ((((((2.0L)*(curr.href))*(params->kp))+((params->v)*(params->y)) < (((2.0L)*(params->h))*(params->kp))+((params->kd)*(params->v))) && ((((2.0L)*(params->h))*(params->kp))+((params->v)*((params->kd)+(params->y))) < ((2.0L)*(curr.href))*(params->kp))) || (((((2.0L)*(curr.href))*(params->kp))+((params->v)*(params->y)) > (((2.0L)*(params->h))*(params->kp))+((params->kd)*(params->v))) || ((((2.0L)*(params->h))*(params->kp))+((params->v)*((params->kd)+(params->y))) > ((2.0L)*(curr.href))*(params->kp))))) || (((2.0L)*(params->v))+((params->h)*((params->kd)+(params->y))) <= 0.0L))) || ((((params->h)*(params->y) >= ((params->h)*(params->kd))+((2.0L)*(params->v))) && (params->kd <= (2.0L)*(params->sqrkp))) || ((params->kd)+((2.0L)*(params->sqrkp)) <= 0.0L))))))) || ((params->kp > 0.0L) && ((params->v > 0.0L) && ((((((2.0L)*(params->h))*(params->kp))+((params->v)*((params->kd)+(params->y))) != ((2.0L)*(curr.href))*(params->kp)) && (((params->kd)+((2.0L)*(params->sqrkp)) >= 0.0L) || (((2.0L)*(params->v))+((params->h)*((params->kd)+(params->y))) >= 0.0L))) || ((params->kd >= (2.0L)*(params->sqrkp)) || ((((params->kd)+((2.0L)*(params->sqrkp)) < 0.0L) && ((((2.0L)*(params->v))+((params->h)*((params->kd)+(params->y))) < 0.0L) && (((((2.0L)*(curr.href))*(params->kp))+((params->v)*(params->y)) < (((2.0L)*(params->h))*(params->kp))+((params->kd)*(params->v))) || (((((2.0L)*(params->h))*(params->kp))+((params->v)*((params->kd)+(params->y))) < ((2.0L)*(curr.href))*(params->kp)) || (((((2.0L)*(curr.href))*(params->kp))+((params->v)*(params->y)) > (((2.0L)*(params->h))*(params->kp))+((params->kd)*(params->v))) && ((((2.0L)*(params->h))*(params->kp))+((params->v)*((params->kd)+(params->y))) > ((2.0L)*(curr.href))*(params->kp))))))) || (((params->kd)+((2.0L)*(params->sqrkp)) > 0.0L) || ((params->h)*(params->y) <= ((params->h)*(params->kd))+((2.0L)*(params->v)))))))))))))) && (((params->y)*(params->y) == ((params->kd)*(params->kd))-((4.0L)*(params->kp))) && ((params->y >= 0.0L) && (((params->sqrkp)*(params->sqrkp) == params->kp) && ((params->sqrkp >= 0.0L) && ((((((((params->h)*(params->h))*((params->kp)*(params->kp)))-((((2.0L)*(params->h))*(curr.href))*((params->kp)*(params->kp))))+(((curr.href)*(curr.href))*((params->kp)*(params->kp))))+((((params->h)*(params->kd))*(params->kp))*(params->v)))-((((curr.href)*(params->kd))*(params->kp))*(params->v)))+((params->kp)*((params->v)*(params->v))) == 0.0L))))))) && (curr.href == curr.href)))",
      paramDecls, "long double href;")
    code._2 shouldBe ""
    CodeGenTestTools.compileC(CodeGenTestTools.augmentMonitorMain(code._1, hasParams=true, hasInputs=false))
  }

  "Compiled controller monitor" should "evaluate boolean correctly" in {
    val inputFile = getClass.getResourceAsStream("/examples/casestudies/robix/passivesafetyabs.kym")
    val monitorExp = KeYmaeraXParser(io.Source.fromInputStream(inputFile).mkString)
    val vars =
      Set(Variable("a"),Variable("dx"),Variable("dy"),Variable("r"),Variable("v"),Variable("w"),Variable("x"),Variable("y"),
        Variable("xo"),Variable("yo"),Variable("dxo"),Variable("dyo"),Variable("t"))
    val monitorCode = (new CGenerator(new CMonitorGenerator()))(monitorExp, vars)._1

    // robot and obstacle drive straight towards each other
    val code =
      s"""
        |#include <stdio.h>
        |$monitorCode
        |
        |state ctrl(state curr, const parameters* const params, const input* const in) { printf("Controller chooses A\\n"); curr.a = params->A; return curr; }
        |state fallback(state curr, const parameters* const params, const input* const in) { printf("Fallback returns -B\\n"); curr.a = -params->B; return curr; }
        |
        |int main() {
        |  state current = { .a=0.0, .dx=1.0, .dy=0.0, .r=1.0, .v=1.0, .w=1.0, .x=0.0, .y=0.0, .xo=10.0, .yo=0.0, .dxo=-1.0, .dyo=0.0, .t=0.0 };
        |  parameters params = { .A=1.0, .B=2.0, .V=1.0, .ep=0.05 };
        |  printf("Returned a=%1.1Lf\\n", monitoredCtrl(current, &params, (const input* const)0, &ctrl, &fallback).a);
        |  /* jump robot ahead and speed up, now unsafe */
        |  state next = { .a=0.0, .dx=1.0, .dy=0.0, .r=1.0, .v=4.0, .w=4.0, .x=9.0, .y=0.0, .xo=10.0, .yo=0.0, .dxo=-1.0, .dyo=0.0 };
        |  printf("Returned a=%1.1Lf", monitoredCtrl(next, &params, (const input* const)0, &ctrl, &fallback).a);
        |  return 0;
        |}
        |""".stripMargin

    val cmd = CodeGenTestTools.compileC(code)
    val p = Runtime.getRuntime.exec(cmd)
    withClue(scala.io.Source.fromInputStream(p.getErrorStream).mkString) {
      p.waitFor() shouldBe 0
      scala.io.Source.fromInputStream(p.getInputStream).mkString shouldBe
        "Controller chooses A\nReturned a=1.0\nController chooses A\nFallback returns -B\nReturned a=-2.0"
    }
  }

  it should "evaluate metric correctly" ignore withMathematica { _ =>
    //@todo mixed open/closed can evaluate to false at the boundary (e.g., x<=5 | x>6 turns into min(x-5,6-x)<0 == false for x=5)
    //      which is especially problematic when monitor contains equalities, e.g., x=5 | x>6
    val inputFile = getClass.getResourceAsStream("/examples/casestudies/robix/passivesafetyabs.kym")
    val monitorExp = ModelPlex.toMetric(io.Source.fromInputStream(inputFile).mkString.asFormula)
    val vars =
      Set(Variable("a"),Variable("dx"),Variable("dy"),Variable("r"),Variable("v"),Variable("w"),Variable("x"),Variable("y"),
        Variable("xo"),Variable("yo"),Variable("dxo"),Variable("dyo"),Variable("t"))
    val monitorCode = (new CGenerator(new CMonitorGenerator))(monitorExp, vars)

    // robot and obstacle drive straight towards each other
    val code =
      s"""
         |#include <stdio.h>
         |$monitorCode
         |
         |state ctrl(state curr, parameters params, input input) { printf("Controller chooses A\\n"); curr.a = params->A; return curr; }
         |state fallback(state curr, parameters params, input input) { printf("Fallback returns -B\\n"); curr.a = -params->B; return curr; }
         |
         |int main() {
         |  state current = { .a=0.0, .dx=1.0, .dy=0.0, .r=1.0, .v=1.0, .w=1.0, .x=0.0, .y=0.0, .xo=10.0, .yo=0.0, .dxo=-1.0, .dyo=0.0, .t=0.0 };
         |  parameters params = { .A=1.0, .B=2.0, .V=1.0, .ep=0.05 };
         |  state input = { 0 };
         |  printf("Returned a=%1.1Lf\\n", monitoredCtrl(current, params, input, &ctrl, &fallback).a);
         |  /* jump robot ahead and speed up, now unsafe */
         |  state next = { .a=0.0, .dx=1.0, .dy=0.0, .r=1.0, .v=4.0, .w=4.0, .x=9.0, .y=0.0, .xo=10.0, .yo=0.0, .dxo=-1.0, .dyo=0.0 };
         |  printf("Returned a=%1.1Lf", monitoredCtrl(next, params, input, &ctrl, &fallback).a);
         |  return 0;
         |}
         |""".stripMargin

    val cmd = CodeGenTestTools.compileC(code)
    val p = Runtime.getRuntime.exec(cmd)
    withClue(scala.io.Source.fromInputStream(p.getErrorStream).mkString) {
      p.waitFor() shouldBe 0
      scala.io.Source.fromInputStream(p.getInputStream).mkString shouldBe
        "Controller chooses A\nReturned a=1.0\nController chooses A\nFallback returns -B\nReturned a=-2.0"
    }
  }

  "Controller generation" should "translate a simple deterministic controller" in {
    val ctrlPrg = "x:=2;".asProgram
    val cPrg = new CControllerGenerator()(ctrlPrg)
    cPrg._1 shouldBe ""
    cPrg._2 shouldBe """state ctrlStep(state curr, const parameters* const params, const input* const in) {
        |  struct { state state; int success; } prg = { .state=curr, .success=0 };
        |  prg.state.x = 2.0L; prg.success = 1;
        |  return prg.state;
        |}""".stripMargin
  }

  it should "translate nested choices" in {
    val ctrlPrg = "x:=2;++x:=3;{x:=4;++x:=5;}".asProgram
    val cPrg = new CControllerGenerator()(ctrlPrg)
    cPrg._1 shouldBe ""
    cPrg._2 shouldBe """state ctrlStep(state curr, const parameters* const params, const input* const in) {
        |  struct { state state; int success; } prg = { .state=curr, .success=0 };
        |  {
        |    state reset = prg.state;
        |    prg.state.x = 2.0L; prg.success = 1;
        |    if (!prg.success) prg.state = reset;
        |  }
        |  if (!prg.success) {
        |    state reset = prg.state;
        |    {
        |      prg.state.x = 3.0L; prg.success = 1;
        |    }
        |    if (prg.success) {
        |      {
        |        state reset = prg.state;
        |        prg.state.x = 4.0L; prg.success = 1;
        |        if (!prg.success) prg.state = reset;
        |      }
        |      if (!prg.success) {
        |        state reset = prg.state;
        |        prg.state.x = 5.0L; prg.success = 1;
        |        if (!prg.success) prg.state = reset;
        |      }
        |    }
        |    if (!prg.success) prg.state = reset;
        |  }
        |  return prg.state;
        |}""".stripMargin
  }

  it should "translate a nondeterministic assignment into an input lookup" in {
    val ctrlPrg = "x:=*;".asProgram
    val cPrg = new CControllerGenerator()(ctrlPrg)
    cPrg._1 shouldBe ""
    cPrg._2 shouldBe """state ctrlStep(state curr, const parameters* const params, const input* const in) {
        |  struct { state state; int success; } prg = { .state=curr, .success=0 };
        |  prg.state.x = in->x; prg.success = 1;
        |  return prg.state;
        |}""".stripMargin
  }

  it should "translate sequential compositions, tests, and nondeterministic choices" in {
    val ctrlPrg = "x:=*;?x<=5; ++ x:=7;".asProgram
    val cPrg = new CControllerGenerator()(ctrlPrg)
    cPrg._1 shouldBe ""
    cPrg._2 shouldBe """state ctrlStep(state curr, const parameters* const params, const input* const in) {
        |  struct { state state; int success; } prg = { .state=curr, .success=0 };
        |  {
        |    state reset = prg.state;
        |    {
        |      prg.state.x = in->x; prg.success = 1;
        |    }
        |    if (prg.success) {
        |      prg.success = (prg.state.x <= 5.0L);
        |    }
        |    if (!prg.success) prg.state = reset;
        |  }
        |  if (!prg.success) {
        |    state reset = prg.state;
        |    prg.state.x = 7.0L; prg.success = 1;
        |    if (!prg.success) prg.state = reset;
        |  }
        |  return prg.state;
        |}""".stripMargin
  }

  it should "look up parameters" in {
    val ctrlPrg = "x:=A;".asProgram
    val cPrg = new CControllerGenerator()(ctrlPrg, Set(Variable("x")))
    cPrg._1 shouldBe ""
    cPrg._2 shouldBe """state ctrlStep(state curr, const parameters* const params, const input* const in) {
        |  struct { state state; int success; } prg = { .state=curr, .success=0 };
        |  prg.state.x = params->A; prg.success = 1;
        |  return prg.state;
        |}""".stripMargin
  }

  it should "look up function parameters" in {
    val ctrlPrg = "x:=A();".asProgram
    val cPrg = new CControllerGenerator()(ctrlPrg, Set(Variable("x")))
    cPrg._1 shouldBe ""
    cPrg._2 shouldBe """state ctrlStep(state curr, const parameters* const params, const input* const in) {
        |  struct { state state; int success; } prg = { .state=curr, .success=0 };
        |  prg.state.x = params->A; prg.success = 1;
        |  return prg.state;
        |}""".stripMargin
  }

  it should "skip ODEs and repeat loops until success" in {
    val ctrlPrg = "{x:=2;{x'=4}}*".asProgram
    val cPrg = new CControllerGenerator()(ctrlPrg)
    cPrg._1 shouldBe ""
    cPrg._2 shouldBe """state ctrlStep(state curr, const parameters* const params, const input* const in) {
        |  struct { state state; int success; } prg = { .state=curr, .success=0 };
        |  while (!prg.success) {
        |    {
        |      prg.state.x = 2.0L; prg.success = 1;
        |    }
        |    if (prg.success) {
        |      prg.success = 1; /* done choosing actuator set values */
        |    }
        |  }
        |  return prg.state;
        |}""".stripMargin
  }

  it should "compile and run a controller" in {
    val ctrlPrg = "x:=*;?x<=A; ++ x:=7;".asProgram
    val code = (new CGenerator(new CControllerGenerator()))(ctrlPrg, Set(Variable("x")), Set(Variable("x")))

    val mainCode =
      s"""
       |#include <stdio.h>
       |${code._1}
       |${code._2}
       |
       |int main() {
       |  state current = { .x=0.0 };
       |  parameters params = { .A=1.0 };
       |  input in = { .x=0.5 };
       |  printf("Returned x=%1.1Lf\\n", ctrlStep(current, &params, &in).x);
       |  /* change input */
       |  input nextIn = { .x=2.0 };
       |  printf("Returned x=%1.1Lf", ctrlStep(current, &params, &nextIn).x);
       |  return 0;
       |}
       |""".stripMargin

    val cmd = CodeGenTestTools.compileC(mainCode)
    val p = Runtime.getRuntime.exec(cmd)
    withClue(scala.io.Source.fromInputStream(p.getErrorStream).mkString) {
      p.waitFor() shouldBe 0
      scala.io.Source.fromInputStream(p.getInputStream).mkString shouldBe
        "Returned x=0.5\nReturned x=7.0"
    }
  }

  it should "compile and run a fallback controller of a monitor" in {
    val ctrlPrg = "x:=*;?x<=A; ++ x:=7;".asProgram
    val monitor = "xpost()<=A | xpost()=7".asFormula // == controller monitor of ctrlPrg

    val stateVars = Set(Variable("x"))
    val params = Set[NamedSymbol](Variable("A"))
    val inputs = Set(Variable("x"))

    val declarations =
      CGenerator.printParameterDeclaration(params) + "\n" +
      CGenerator.printStateDeclaration(stateVars) + "\n" +
      CGenerator.printInputDeclaration(inputs)
    val fallbackCode = new CControllerGenerator()(ctrlPrg, stateVars)._2
    val monitorCode = new CMonitorGenerator()(monitor, stateVars)._1

    val code = s"""
       |#include <stdio.h>
       |${CGenerator.INCLUDE_STATEMENTS}
       |$declarations
       |$fallbackCode
       |$monitorCode
       |
       |state ctrl(state curr, const parameters* const params, const input* const in) { printf("Choosing 2*%1.1Lf", curr.x); curr.x = 2*curr.x; return curr; }
       |
       |int main() {
       |  state current = { .x=0.2 };
       |  parameters params = { .A=1.0 };
       |  long double inputSequence[5] = { 3.0, 3.0, 3.0, 1.0, 0.5 };
       |  for (int i=0; i<5; ++i) {
       |    input in = { .x=inputSequence[i] };
       |    current = monitoredCtrl(current, &params, &in, &ctrl, &ctrlStep);
       |    printf(", result x=%1.1Lf\\n", current.x);
       |  }
       |  return 0;
       |}
       |""".stripMargin

    val cmd = CodeGenTestTools.compileC(code)
    val p = Runtime.getRuntime.exec(cmd)
    withClue(scala.io.Source.fromInputStream(p.getErrorStream).mkString) {
      p.waitFor() shouldBe 0
      scala.io.Source.fromInputStream(p.getInputStream).mkString shouldBe
        """Choosing 2*0.2, result x=0.4
          |Choosing 2*0.4, result x=0.8
          |Choosing 2*0.8, result x=7.0
          |Choosing 2*7.0, result x=1.0
          |Choosing 2*1.0, result x=0.5
          |""".stripMargin
    }
  }

  it should "execute nondeterministic choices in a fallback controller with correct reset" in {
    val ctrlPrg = "x:=1; { {x:=2;?x<=1;} ++ {x:=3;?x<=1;} }".asProgram
    val monitor = "xpost()<=A | xpost()=7".asFormula // == controller monitor of ctrlPrg

    val stateVars = Set(Variable("x"))
    val params = Set[NamedSymbol](Variable("A"))

    val declarations =
      CGenerator.printParameterDeclaration(params) + "\n" +
        CGenerator.printStateDeclaration(stateVars) + "\n" +
        CGenerator.printInputDeclaration(Set())
    val fallbackCode = new CControllerGenerator()(ctrlPrg, stateVars)._2
    val monitorCode = new CMonitorGenerator()(monitor, stateVars)._1

    val code = s"""
      |#include <stdio.h>
      |${CGenerator.INCLUDE_STATEMENTS}
      |$declarations
      |$fallbackCode
      |$monitorCode
      |
      |state ctrl(state curr, const parameters* const params, const input* const in) { printf("Choosing 2"); curr.x = 2.0L; return curr; }
      |
      |int main() {
      |  state current = { .x=0.2 };
      |  parameters params = { .A=1.0 };
      |  current = monitoredCtrl(current, &params, 0, &ctrl, &ctrlStep);
      |  printf(", result x=%1.1Lf\\n", current.x);
      |  return 0;
      |}
      |""".stripMargin

    val cmd = CodeGenTestTools.compileC(code)
    val p = Runtime.getRuntime.exec(cmd)
    withClue(scala.io.Source.fromInputStream(p.getErrorStream).mkString) {
      p.waitFor() shouldBe 0
      scala.io.Source.fromInputStream(p.getInputStream).mkString shouldBe
        """Choosing 2, result x=1.0
          |""".stripMargin
    }
  }
}
